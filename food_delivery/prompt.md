# Food Delivery System

**_ This problem was generated by ChatGPT _**

## ðŸ§ª Simulation Prompt: FoodDeliverySystem

You're implementing a backend simulation for a simplified food delivery dispatch system. There is no database or UIâ€”just a core class with methods to handle food orders and delivery drivers. Youâ€™ll build it over 4 levels.

Your goal: get each level passing all tests before moving on. Prioritize correctness and forward progress over elegance.

âœ… Constraints
Use only the standard Python library.

Donâ€™t worry about concurrency, timeouts, or performance.

Focus on correctness, state management, and careful spec-following.

ðŸ”§ Setup
Start with:

```
class FoodDeliverySystem:
    def **init**(self):
        pass
```

## ðŸ§© Level 1: Basic order and driver matching

Implement two methods:

```
def place_order(self, order_id: str) -> None:
"""A new food order has been placed."""

def driver_available(self, driver_id: str) -> None:
"""A new driver is now available to take an order."""

def get_assignments(self) -> List[Tuple[str, str]]:
"""Return a list of (order_id, driver_id) pairs that have been assigned."""
```

Rules:

- Orders and drivers are matched in FIFO order.
- Once matched, orders and drivers are no longer available.
- get_assignments() returns all current matches.

Example:

```
fds = FoodDeliverySystem()
fds.place_order("order1")
fds.place_order("order2")
fds.driver_available("driverA")
fds.driver_available("driverB")
print(fds.get_assignments())

# â†’ [("order1", "driverA"), ("order2", "driverB")]
```

## ðŸ§© Level 2: Cancellations and edge cases

Add:

```
def cancel_order(self, order_id: str) -> None:
"""Cancel a pending order. Has no effect if already assigned."""

def cancel_driver(self, driver_id: str) -> None:
"""Cancel a pending driver. Has no effect if already assigned."""
```

Behavior:
Cancellations should remove the order or driver from the pending queue if not yet assigned.
If either is already assigned, do nothing.

Example:

```
fds = FoodDeliverySystem()
fds.place_order("order1")
fds.place_order("order2")
fds.cancel_order("order1")
fds.driver_available("driverA")
print(fds.get_assignments())

# â†’ [("order2", "driverA")]
```

## ðŸ§© Level 3: Priority orders

Now allow certain orders to be priority orders, which jump to the front of the line.

Update place_order:

```
def place_order(self, order_id: str, priority: bool = False) -> None:
"""If priority=True, the order goes ahead of all non-priority orders."""
```

Rules:

- Priority orders are assigned before any non-priority orders, regardless of placement time.
- Among themselves, priority orders are still FIFO.

Example:

```
fds = FoodDeliverySystem()
fds.place_order("order1")
fds.place_order("order2")
fds.place_order("orderP", priority=True)
fds.driver_available("driverX")
fds.driver_available("driverY")
print(fds.get_assignments())

# â†’ [("orderP", "driverX"), ("order1", "driverY")]
```

## ðŸ§© Level 4: Tracking status

Add:

```
def get_status(self, order_id: str) -> str:
"""Return 'pending', 'cancelled', or 'assigned'"""

def get_driver_status(self, driver_id: str) -> str:
"""Return 'waiting', 'cancelled', or 'assigned'"""
```

Rules:
Orders are:

- 'pending' if placed but not yet assigned
- 'cancelled' if cancelled
- 'assigned' if matched to a driver

Drivers are:

- 'waiting' if available but not yet assigned
- 'cancelled' if cancelled
- 'assigned' if matched
